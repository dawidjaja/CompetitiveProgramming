<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"><title>gdb Tutorial</title></head>
<body bgcolor="#ffffff" text="#000000">

<center><h1>Debugging Under Unix: <code>gdb</code> Tutorial</h1></center>
<h2>Contents</h2>
<ol>
<li><a href="#1">Introduction</a></li>
<ol>
<li><a href="#1.1">Who should read this?</a></li>
<li><a href="#1.2">Source code</a></li>
</ol>
<li><a href="#2">Preparations</a></li>
<ol>
<li><a href="#2.1">Environment settings</a></li>
<li><a href="#2.2">Debugging symbols</a></li>
</ol>
<li><a href="#3">Debugging</a></li>
<ol>
<li><a href="#3.1">When to use a debugger</a></li>
<li><a href="#3.2">Loading a program</a></li>
<li><a href="#3.3">Inspecting crashes</a></li>
<li><a href="#3.4">Conditional breakpoints</a></li>
<li><a href="#3.5">Stepping</a></li>
</ol>
<li><a href="#4">Further information</a></li>
<li><a href="#5">Notes</a></li>
</ol>

<hr>

<h2><a name="1"></a>Introduction</h2>

This tutorial was originally written for <a href="http://www.cs.wustl.edu/%7Ecdgill/courses/cs342">CS 342</a> at <a href="http://www.wustl.edu/">Washington University</a>. It is still
maintained by <a href="http://www.cs.cmu.edu/%7Egilpin/">Andrew
Gilpin</a>.

<h3><a name="1.1"></a>Who should read this?</h3>
This tutorial is written to help a programmer who is new to the Unix
environment to get started with using the <code>gdb</code> debugger. This
tutorial assumes you already know how to program in C++ and you can compile and
execute programs. It also sort of assumes that you basically know what
debugging is and that you have used a debugger on another system.

<h3><a name="1.2"></a>Source code</h3>
To help illustrate some of the debugging principles I will use a running
example of a buggy program. As you progress through this tutorial, you
will use the debugger to locate and fix errors in the code. The code can be
downloaded <a href="http://www.cs.cmu.edu/%7Egilpin/tutorial/main.cc">here</a> and a simple Makefile for the program
can be downloaded <a href="http://www.cs.cmu.edu/%7Egilpin/tutorial/Makefile">here</a>.
<p>
The code is very simple and consists of two class definitions, a node and a
linked list. There is also a simple driver to test the list. All of the code
was placed into a single file to make illustrating the process of debugging
a little easier.
</p><hr>

<h2><a name="2"></a>Preparations</h2>

<h3><a name="2.1"></a>Environment settings</h3>
<code>gdb</code> is in the gnu package on CEC machines. If you don't
have this package loaded then type <code>pkgadd gnu</code> at a shell
prompt. If you can run <code>g++</code>, then you will be able to run <code>gdb</code>.

<h3><a name="2.2"></a>Debugging symbols</h3>
<code>gdb</code> can only use debugging symbols that are generated by
<code>g++</code>. For Sun CC users, there is the <code>dbx</code> debugger
which is very similar to <code>gdb</code>.
<p>
<code>gdb</code> is most effective when it is debugging a program that has
debugging symbols linked in to it. With <code>g++</code>, this is accomplished
using the <code>-g</code> command line argument.
For even more information, the <code>-ggdb</code> switch
can be used which includes debugging symbols which are specific to
<code>gdb</code>. The makefile for this tutorial uses the
<code>-ggdb</code> switch.

</p><hr>

<h2><a name="3"></a>Debugging</h2>

<h3><a name="3.1"></a>When to use a debugger</h3>
Debugging is something that can't be avoided. Every programmer will at one
point in their programming career have to debug a section of code. There
are many ways to go about debugging, from printing out messages to the screen,
using a debugger, or just thinking about what the program is doing and
making an educated guess as to what the problem is.
<p>
Before a bug can be fixed, the source of the bug must be located. For example,
with segmentation faults, it is useful to know on which line of code the
seg fault is occuring. Once the line of code in question has been found, it
is useful to know about the values in that method, who called the method, and
why (specifically) the error is occuring. Using a debugger makes finding all
of this information very simple.
</p><p>
Go ahead and make the program for this tutorial, and run the program. The
program will print out some messages, and then it will print that it has
received a segmentation fault signal, resulting in a program crash. Given
the information on the screen at this point, it is near impossible to determine
why the program crashed, much less how to fix the problem. We will now
begin to debug this program.

</p><h3><a name="3.2"></a>Loading a program</h3>
So you now have an executable file (in this case <code>main</code>) and you
want to debug it. First you must launch the debugger. The debugger is called
<code>gdb</code> and you can tell it which file to debug at the shell prompt.
So to debug <code>main</code> we want to type <code>gdb main</code>. Here is
what it looks like when I run it:
<pre>agg1@sukhoi agg1/.www-docs/tutorial&gt; gdb main
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "sparc-sun-solaris2.7"...
(gdb)
</pre>
(Note: If you are using Emacs, you can run <code>gdb</code> from within Emacs by
typing M-x gdb. Then Emacs will split into two windows, where the second
window will show the source code with a cursor at the current instruction. I
haven't actually used gdb this way, but I have been told by a very reliable
source that this will work. :)
<p>
<code>gdb</code> is now waitng for the user to type a command. We need to
run the program so that the debugger can help us see what happens when
the program crashes. Type <code>run</code> at the <code>(gdb)</code> prompt.
Here is what happens when I run this command:
</p><pre>(gdb) run
Starting program: /home/cec/s/a/agg1/.www-docs/tutorial/main 
Creating Node, 1 are in existence right now
Creating Node, 2 are in existence right now
Creating Node, 3 are in existence right now
Creating Node, 4 are in existence right now
The fully created list is:
4
3
2
1

Now removing elements:
Creating Node, 5 are in existence right now
Destroying Node, 4 are in existence right now
4
3
2
1


Program received signal SIGSEGV, Segmentation fault.
Node&lt;int&gt;::next (this=0x0) at main.cc:28
28	  Node&lt;T&gt;* next () const { return next_; }
(gdb)
</pre>
The program crashed so lets see what kind of information we can gather.
<h3><a name="3.3"></a>Inspecting crashes</h3>
So already we can see the that the program was at line 28 of main.cc, that
<code>this</code> points to 0, and we can see the line of code that was executed. But
we also want to know who called this method and we would like to be able to
examine values in the calling methods. So at the <code>gdb</code> prompt,
we type <code>backtrace</code> which gives me the following output:
<pre>(gdb) backtrace
#0  Node&lt;int&gt;::next (this=0x0) at main.cc:28
#1  0x2a16c in LinkedList&lt;int&gt;::remove (this=0x40160, 
    item_to_remove=@0xffbef014) at main.cc:77
#2  0x1ad10 in main (argc=1, argv=0xffbef0a4) at main.cc:111
(gdb)
</pre>
So in addition to what we knew about the current method and the local
variables, we can now also see what methods called us and what their
parameters were. For example, we can see that we were called by
<code>LinkedList&lt;int&gt;::remove ()</code> where the parameter
<code>item_to_remove</code> is at address <code>0xffbef014</code>. It
may help us to understand our bug if we know the value of
<code>item_to_remove</code>, so we want to see the value at the
address of <code>item_to_remove</code>. This can be done using the
<code>x</code> command using the address as a parameter.  ("x" can be
thought of as being short for "examine".) Here is what happens when I
run the command:
<pre>(gdb) x 0xffbef014
0xffbef014:	0x00000001
(gdb)
</pre>
So the program is crashing while trying to run
<code>LinkedList&lt;int&gt;::remove</code> with a parameter of 1. We have now
narrowed the problem down to a specific function and a specific value for
the parameter.
<h3><a name="3.4"></a>Conditional breakpoints</h3>
Now that we know where and when the segfault is occuring, we want to
watch what the program is doing right before it crashes. One way to do this
is to step through, one at a time, every statement of the program until
we get to the point of execution where we want to see what is happening. This
works, but sometimes you may want to just run to a particular section of code
and stop execution at that point so you can examine data at that location.
<p>
If you have ever used a debugger you are probably familiar with the concept
of breakpoints. Basically, a breakpoint is a line in the source code where
the debugger should break execution. In our example, we want to look at the
code in <code>LinkedList&lt;int&gt;::remove ()</code> so we would want to set a
breakpoint at line 52 of main.cc. Since you may not know the exact line
number, you can also tell the debugger which function to break in. Here is
what we want to type for our example:
</p><pre>(gdb) break LinkedList&lt;int&gt;::remove
Breakpoint 1 at 0x29fa0: file main.cc, line 52.
(gdb)
</pre>
So now Breakpoint 1 is set at main.cc, line 52 as desired. (The reason the
breakpoint gets a number is so we can refer to the breakpoint later, for
example if we want to delete it.) So when the program is run, it will return
control to the debugger everytime it reaches line 52. This may not be
desirable if the method is called many times but only has problems with
certain values that are passed. Conditional breakpoints can help us here.
For our example, we know that the program
crashes when <code>LinkedList&lt;int&gt;::remove()</code> is called with a value of
1. So we might want to tell the debugger to only break at line 52 if
<code>item_to_remove</code> is equal to 1. This can be done by issuing
the following command:
<pre>(gdb) condition 1 item_to_remove==1
(gdb)
</pre>
This basically says "Only break at Breakpoint 1 if the value of
<code>item_to_remove</code> is 1." Now we can run the program and know that
the debugger will only break here when the specified condition is true.

<h3><a name="3.5"></a>Stepping</h3>
Continuing with the example above, we have set a conditional
breakpoint and now want to
go through this method one line at a time and see if we can locate the source
of the error. This is accomplished using the <code>step</code> command.
<code>gdb</code> has the nice feature that when enter is pressed without
typing a command, the last command is automatically used. That way we can step
through by simply tapping the enter key after the first <code>step</code>
has been entered. Here is what this looks like:
<pre>(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /home/cec/s/a/agg1/.www-docs/tutorial/main 
Creating Node, 1 are in existence right now
Creating Node, 2 are in existence right now
Creating Node, 3 are in existence right now
Creating Node, 4 are in existence right now
The fully created list is:
4
3
2
1

Now removing elements:
Creating Node, 5 are in existence right now
Destroying Node, 4 are in existence right now
4
3
2
1


Breakpoint 1, LinkedList&lt;int&gt;::remove (this=0x40160, 
    item_to_remove=@0xffbef014) at main.cc:52
52	    Node&lt;T&gt; *marker = head_;
(gdb) step
53	    Node&lt;T&gt; *temp = 0;  // temp points to one behind as we iterate
(gdb) 
55	    while (marker != 0) {
(gdb) 
56	      if (marker-&gt;value() == item_to_remove) {
(gdb) 
Node&lt;int&gt;::value (this=0x401b0) at main.cc:30
30	  const T&amp; value () const { return value_; }
(gdb) 
LinkedList&lt;int&gt;::remove (this=0x40160, item_to_remove=@0xffbef014)
    at main.cc:75
75	      marker = 0;  // reset the marker
(gdb) 
76	      temp = marker;
(gdb) 
77	      marker = marker-&gt;next();
(gdb) 
Node&lt;int&gt;::next (this=0x0) at main.cc:28
28	  Node&lt;T&gt;* next () const { return next_; }
(gdb) 

Program received signal SIGSEGV, Segmentation fault.
Node&lt;int&gt;::next (this=0x0) at main.cc:28
28	  Node&lt;T&gt;* next () const { return next_; }
(gdb)
</pre>
After typing <code>run</code>, <code>gdb</code> asks us if we want to restart
the program, which we do. It then proceeds to run and breaks at the
desired location in the program. Then we type <code>step</code> and proceed
to hit enter to step through the program. Note that the debugger steps into
functions that are called. If you don't want to do this, you can use
<code>next</code> instead of <code>step</code> which otherwise has the same
behavior.
<p>
The error in the program is obvious.
At line 75 marker is set to 0, but at line 77 a member of marker is accessed.
Since the program can't access memory location 0, the seg fault occurs. In
this example, nothing has to be done to marker and the error can be avoided
by simply removing line 75 from main.cc.
</p><p>
If you look at the output from running the program, you will see first of all
that the program runs without crashing, but there is a memory leak somewhere
in the program. (Hint: It is in the LinkedList&lt;T&gt;::remove() function.
One of the cases for remove doesn't work properly.) It is
left as an exercise to the reader to use the debugger in locating and fixing
this bug. (I've always wanted to say that. ;)
</p><p>
<code>gdb</code> can be exited by typing <code>quit</code>.

</p><hr>

<h2><a name="4"></a>Further information</h2> This document only covers
the bare minimum number of commands necessary to get started using
<code>gdb</code>.  For more information about <code>gdb</code> see the
<code>gdb</code> man page or take a look at a very long description of
<code>gdb</code> <a href="http://sources.redhat.com/gdb/current/onlinedocs/gdb_toc.html">here</a>.
Online help can be accessed by typing <code>help</code> while running
<code>gdb</code>.  Also, as always, feel free to ask questions on the
newsgroup or you can ask me during lab hours.

<hr>

<h2><a name="5"></a>Notes</h2>

<ul>
<li>There is another bug in the source code for the linked list that is not
mentioned in the above code. The bug does not show up for the sequence
of inserts and removes that are in the provided driver code, but for other
sequences the bug shows up. For example, inserting 1, 2, 3, and 4, and then
trying to remove 2 will show the error. Special thanks to Linda Gu and
Xiaofeng Chen for locating this bug. The bug fix is pretty simple and is
left as an exercise.</li>
<li>Special thanks to Ximmbo da Jazz for providing valuable fixes for
some typos and erroneous output.</li>
<li>Special thanks to Raghuprasad Govindarao for discovering a broken
link.</li>
</ul>

<hr>
Please send comments, suggestions, and bug reports to
<a href="mailto:gilpin@cs.cmu.edu">Andrew Gilpin</a>.

<p>
Page last modified: April 7, 2004



</p></body></html>