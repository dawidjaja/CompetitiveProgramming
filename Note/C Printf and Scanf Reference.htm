<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<title> C Printf and Scanf Reference </title>
<meta name="author" content="Wayne Pollock">
<link rev="MADE" href="mailto:pollock@acm.org">
<link rel="CONTENTS" href="http://wpollock.com/COP1220.htm">
<link rel="PREVIOUS" href="http://wpollock.com/COP1220.htm">
</head>
<body alink="#CC0000" bgcolor="#333399" link="#FFFF00" text="#FFFFFF" vlink="#FF9900">
<center>
<h1> C Printf and Scanf Reference </h1>
©2001 by Wayne Pollock, Tampa Florida USA.&nbsp;
All Rights Reserved.
</center>

<h2> Table of Contents </h2>
<dir><a href="#Background">Background</a>
<br><br><a href="#printf">printf</a>
<dir>
<a href="#printfConv">Conversion types (letters)</a>
<br><a href="#printfFormat">Format Control (Modifiers)</a>
<dir>
<a href="#printfFlags">Flags</a>
<br><a href="#printfWidth">Minimum Field Width</a>
<br><a href="#printfPrec">Precision</a>
<br><a href="#printfLen">Length</a>
</dir></dir>
<br><a href="#scanf">scanf</a>
<dir>
<a href="#scanfRetCode">Return Values</a>
<br><a href="#scanfMatch">Input Matching</a>
<br><a href="#scanfConv">Conversion types (letters)</a>
<br><a href="#scanfFormat">Format Control (Modifiers)</a>
<dir>
<a href="#scanfAssign">Assignment Supression Flag</a>
<br><a href="#scanfWidth">Field Width</a>
<br><a href="#scanfLen">Length</a>
</dir>
<a href="#scanfExamples">Examples Using scanf and Other Input Techniques</a>
</dir>
<br><a href="#CharConstants">Character Constants</a>
<br><br><a href="#About">About This Document</a>
</dir>

<br><br><br>
<h2> <a name="Background">Background</a> </h2>
<p>
<tt>printf</tt> and <tt>scanf</tt> are the two standard C programming
language functions for console input and output.&nbsp;
A variation of these commands (<tt>fprintf</tt> and <tt>fscanf</tt>)
also allows I/O to files.&nbsp;
Another (<tt>sprintf</tt> and <tt>sscanf</tt>) allows I/O to strings.&nbsp;
(<tt>sscanf</tt> is especially useful.)&nbsp;
All these as well as many other I/O functions are declared in the
standard header file <tt>&lt;stdio.h&gt;</tt>.
</p>
<p>
Using <tt>scanf</tt> is tricker than <tt>printf</tt>.&nbsp;
This is because of <i>promotion</i>, so that any type smaller than
an <tt>int</tt> is promoted to an <tt>int</tt> when passed to
<tt>printf</tt>, and <tt>float</tt>s are promoted to <tt>double</tt>.&nbsp;
This means there is a single code for most integers and one for most
floating point types.&nbsp;
There is no such promotion with <tt>scanf</tt> arguments, which are
actually <i>pointers</i>.&nbsp;
So all types must be exactly specified.&nbsp;
In addition there are security concerns with input that don't apply to
output.&nbsp;
(These will be discussed below.&nbsp;
In particular, <i>never</i> use the <tt>gets()</tt> function in
production-quality C code!)
</p>
<br>
<h2> <a name="printf">printf</a> </h2>
<p>
A call to <tt>printf</tt> looks like this:
</p><dir><pre>printf( "<i>format-string</i>", <i>expression,</i> ... );</pre></dir>
<p>Or you can use <tt>fprintf</tt> to send the output to the screen regardless of
any <i>output redirection</i> like this:
</p><dir><pre>fprintf( stderr, "<i>format-string</i>", <i>expression,</i> ... );</pre></dir>
<p>
The <i>format-string</i> can contain <a href="#CharConstants">regular characters</a>
which are simply
printed out, and <i>format specifications</i> or <i>place-holders</i>.&nbsp;
For each place-holder in the format-string there must be one matching
expression.&nbsp;
The expressions are converted to strings according to the instructions in
the corresponding place-holder and are mixed with the regular text in
the format-string.&nbsp;
Then the whole string is output.&nbsp;
Here's an example:
</p><dir><pre>printf( "%i + %i = %i\n", 2, 3, (2+3) );</pre></dir>
will produce the following output (by converting the three integer arguments
to strings using default formatting):<dir><pre>2 + 3 = 5
</pre></dir>
<p>
The following table shows the different format letters you can use with
<tt>printf</tt>.&nbsp;
Each letter corresponds to a different type of argument expression.&nbsp;
It is important to use the correct letter that matches the type
of the expression.&nbsp;
The use of any other letter results in undefined behavior.&nbsp;
(Note the <tt>%a</tt> and <tt>%A</tt> are only available in C99, the
others should be available with any standard C compiler.)&nbsp;
The arguments can be any expression of the correct type (such as literals),
but usually are variables whose values were computer earlier.
</p>
<p>
In the examples, remember that <tt>17</tt> is an <tt>int</tt> literal,
<tt>17L</tt> is a <tt> long int</tt> literal, <tt>017</tt> is an <tt>unsigned</tt>
octal literal (with the decimal value 1*8 + 7 = 15), <tt>0x17</tt>, <tt>0X1A</tt>
are <tt>unsigned</tt> hexidecimal literals with decimal values of 1*16 + 7 = 23,
and 1*16 + A = 16 + 10 = 26, <tt>17u</tt> is an <tt>unsigned</tt> decimal integer
literal, <tt>'A'</tt> is a <tt>char</tt> literal with a decimal value of 65,
<tt>3.14</tt> and <tt>0.314E1</tt> are <tt>double</tt> literals, <tt>3.14f</tt>
is a <tt>float</tt> literal, and finally <tt>3.14L</tt> is a <tt>long double</tt>
literal.
</p>
<a name="printfConv"></a>
<center><table border="1" cellpadding="6">
<caption align="TOP"><big><tt>printf</tt> Conversion Letters and Matching Types</big></caption>
<tbody><tr><th>Letter</th><th>Type of Matching Argument</th><th>Example</th><th>Output</th></tr>
<tr><td align="CENTER">%</td><td><i>none</i> (<a href="#" onclick="alert('Outputs a % character.  This doesn\'t match any arguments.'); return false;">
See note</a>)</td>
<td><tt>printf( "%%" );</tt></td><td><tt>%</tt></td></tr>
<tr><td align="CENTER">d, i</td><td><tt>int</tt> (<a href="#%22" onclick="alert('\'%d\' is identical to the newer \'%i\'.  These also match arguments '
         + 'of char, short, and _Bool (in C99), as these are automatically'
         + ' promoted to int when passing these to printf.'); return false;">
See note</a>)</td>
<td><tt>printf( "%i", 17 );</tt></td><td><tt>17</tt></td></tr>
<tr><td align="CENTER">u</td><td><tt>unsigned int</tt> (<i>Converts to decimal</i>)</td>
<td><tt>printf( "%u", 17u );</tt></td><td><tt>17</tt></td></tr>
<tr><td align="CENTER">o</td><td><tt>unsigned int</tt> (<i>Converts to octal</i>)</td>
<td><tt>printf( "%o", 17 );</tt></td><td><tt>21</tt></td></tr>
<tr><td align="CENTER">x</td><td><tt>unsigned int</tt>
(<i>Converts to lower-case hex</i>)</td>
<td><tt>printf( "%x", 26 );</tt></td><td><tt>1a</tt></td></tr>
<tr><td align="CENTER">X</td><td><tt>unsigned int</tt>
(<i>Converts to upper-case hex</i>)</td>
<td><tt>printf( "%X", 26 );</tt></td><td><tt>1A</tt></td></tr>
<tr><td align="CENTER">f, F</td><td><tt>double</tt>
(<a href="#" onclick="alert('A division by zero produces \'nan\', \'inf\', or \'infinity\''
        + ' when using \'%f\' (lower-case f).  Using \'%F\' (upper-case) produces '
        + '\'NAN\', \'INF\', or \'INFINITY\' instead.  (This applies to \'%g\' and \'%G\', '
        + '\'%e\' and \'%E\', and \'%a\' and \'%A\' as well.)'); return false;">
See note</a>)</td>
<td><tt>printf( "%f", 3.14 );</tt></td><td><tt>3.140000</tt></td></tr>
<tr><td align="CENTER">e, E</td><td><tt>double</tt>
(<a href="#" onclick="alert('Using \'%e\' (lower-case e) produces lower-case \'e\'.  Using \'%E\' '
        + '(upper-case) produces upper-case \'E\' on output.  (Note the argument passed to '
        + 'printf can be a variable or literal double in either form.'); return false;">
See note</a>)</td>
<td><tt>printf( "%e", 31.4 );</tt></td><td><tt>3.140000e+01</tt></td></tr>
<tr><td align="CENTER">g, G</td><td><tt>double</tt>
(<a href="#" onclick="alert('Using \'%g\' produces \'%f\' or \'%e\' style output, depending if the '
        + 'exponent is less than -4.  Trailing zeros are removed.  Using \'%G\' '
        + 'instead produces upper-case output.'); return false;">
See note</a>)</td>
<td><tt>printf( "%g, %g", 3.14, 0.0000314 );</tt></td><td><tt>3.14, 3.14e-05</tt></td></tr>
<tr><td align="CENTER">a, A</td><td><tt>double</tt>
(<a href="#" onclick="alert('Like \'%e\' and \'%E\' but used hex digits and a \'p\' or \'P\' for the '
        + 'exponent.  Using \'%a\' (lower-case a) produces lower-case letters, using '
        + '\'%A\' produces upper-case on output.  (Note the \'p\', since \'e\' would be '
        + 'interpreted as a hex digit.)  New as of C99.'); return false;">
See note</a>)</td>
<td><tt>printf( "%a", 31.0 );</tt></td><td><tt>0x1.fp+0</tt></td></tr>
<tr><td align="CENTER">c</td><td><tt>int</tt> (<a href="#" onclick="alert('Converts to an unsigned int, then displays the corresponding (ASCII) '
        + 'character.'); return false;">See note</a>)</td>
<td><tt>printf( "%c", 65 );</tt></td><td><tt>A</tt></td></tr>
<tr><td align="CENTER">s</td><td><i>string</i> (<a href="#" onclick="alert('A string is either a string literal, or an array of char with a zero '
        + '(null) char to mark the end.'); return false;">See note</a>)</td>
<td><tt>printf( "%s", "Hello" );</tt></td><td><tt>Hello</tt></td></tr>
<tr><td align="CENTER">p</td><td><tt>void*</tt> (<a href="#" onclick="alert('Converts a pointer to any type to an implementation-dependent string '
        + '(which can be read back with scanf on that machine).'); return false;">See note</a>)</td>
<td><tt>int a = 1; printf( "%p", &amp;a );</tt></td><td><tt>0064FE00</tt></td></tr>
<tr><td align="CENTER">n</td><td><tt>int*</tt> (<a href="#" onclick="alert('Stores in the int pointed to, the number of characters output so far '
        + 'by this call to printf.  (Rarely used.)'); return false;">See note</a>)</td>
<td><tt>int a; printf( "ABC%n", &amp;a );</tt></td><td><tt>ABC</tt>&nbsp; (<i>a==3</i>)</td></tr>
</tbody></table></center>

<br><br>
<a name="printfFormat"></a>
<h3> <tt>printf</tt> Conversion Specification Formatting Syntax </h3>
<p>
To control the appearance of the converted arguments, any or all (or none) of
the following format controls may be used between the % and the final letter of the
conversion specification.&nbsp;
Note these must appear (if at all) in the sequence shown here.&nbsp;
A <tt>·</tt> is used to indicate a space in the example output where spacing is not obvious.
</p><dir><nobr><tt>% &nbsp; <i>flags &nbsp; minimum-field-width &nbsp; .precision &nbsp; length</i>
&nbsp; Letter</tt></nobr>
</dir>
<br><br>
<a name="printfFlags"></a>
<table border="1" cellpadding="6">
<tbody><tr><th>Format Control</th><th>Description</th><th>Example</th><th>Output</th></tr>

<tr valign="TOP"><th rowspan="6">flags</th><td colspan="3">
The flag characters may appear in any order and have the following meanings:

</td></tr><tr valign="TOP"><td>
<tt>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> left-justify within the field.&nbsp; <nobr>(<a href="#" onclick="alert('Right-justified is the default.  '
+ '(This flag is commonly used with \'%-s\'.)'); return false;">See
note</a>)</nobr></td>
<td><tt>printf(&nbsp;"|%3i|%-3i|",&nbsp;12,&nbsp;12);</tt></td><td><tt>|·12|12·|</tt></td></tr>

<tr valign="TOP"><td><tt>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
Forces positive numbers to include a leading plus sign.</td>
<td><tt>printf( "%+i", 17);</tt></td><td><tt>+17</tt></td></tr>

<tr valign="TOP"><td><tt><i>space&nbsp;</i></tt> Forces positive number to include a leading space.&nbsp;
<nobr>(<a href="#" onclick="alert('A negative number always includes a leading minus sign.  '
       + 'If used with the + flag, the space flag is ignored.'); return false;">See note</a>)</nobr></td>
<td><tt>printf( "|% i|", 12);</tt></td><td><tt>|·12|</tt></td></tr>

<tr valign="TOP"><td><tt>#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> This flag forces the output to be in some
<i>alternate form</i>.&nbsp; <nobr>(<a href="#" onclick="alert(
'The form depends upon the conversion letter used.  For %#o (octal), include a leading zero.  '
+ 'For %#x (hex), include a leading \'0x\'.  For any floating point conversion, '
+ 'always include a decimal point even if no digits follow.  '
+ 'For %#g and %#G, trailing zeros are not removed.'); return false;">See note</a>)</nobr></td>
<td><tt>printf( "%#X", 26);</tt></td><td><tt>0X1A</tt></td></tr>

<tr valign="TOP"><td><tt>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>
Pad with zeros rather than spaces.&nbsp; <nobr>(<a href="#" onclick="alert('This flag is ignored when the - (left-justify) flag is used, '
+ 'or if a precision is used with a d, i, o, u, x, or X (i.e., integer) '
+ 'conversion letter.'); return false;">See note</a>)</nobr></td>
<td><tt>printf( "|%04i|", 12);</tt></td><td><tt>|0012|</tt></td></tr>

<tr valign="TOP"><th rowspan="2">
<a name="printfWidth"></a>
minimum<br>field-width
</th><td>
After converting any value to a string, the field width represents the minimum number
of characters in the resulting string.&nbsp;
(<a href="#" onclick="alert('A common mistake is to interpret this as a maximum '
+ 'field width, but it is a minimum.  The resulting field may be larger than the '
+ 'value used (in which case no padding is needed).  The width includes the entire '
+ 'converted string (including leading sign, decimal point, and any fraction digits).'); return false;">See
note</a>.)&nbsp;
If the converted value has fewer characters, then the resulting string is <i>padded</i>
with spaces (or zeros) on the left (or right) by default (or if the appropriate flag is
used.)</td>
<td><tt>printf( "|%5s|", "ABC");</tt></td><td><tt>|··ABC|</tt></td></tr>

<tr valign="TOP"><td>
Sometimes the minimum field width isn't known at compile-time, and must be computed
at run-time.&nbsp;
(For example, printing a table where the width of a column depends on the widest column
value in the input.)&nbsp;
In this case the field width can be specified as an asterisk ("<tt>*</tt>"), which acts
like a <i>place-holder</i> for an <tt>int</tt> value used for the field width.&nbsp;
The value appears in the argument list before the expression being converted.</td>
<td><tt>printf( "|%-*s|", 5, "ABC" );</tt></td><td><tt>|ABC··|</tt></td></tr>

<tr valign="TOP"><th rowspan="4">
<a name="printfPrec"></a>
.precision
</th><td colspan="3">
A period by itself implies a precision of zero.&nbsp;
A precision may be replaced with an asterisk ("*"), which works exactly the same as for an
asterisk minimum field width described above.&nbsp;
The meaning of a precision depends on the type of conversion done.&nbsp;
Only the conversions listed below are defined:</td></tr>
<tr><td>
When used with floating-point conversion letters (a, A, e, E, f, F, g, and G) the precision specifies
how many digits will appear to the right of the decimal point.&nbsp;
The default precision is six.&nbsp;
(For conversion letters g and G, the precision is actually the maximum number of significant digits.)&nbsp;
The value displayed is always rounded, but note this doesn't change the matching expression in any way.&nbsp;
If the precision is zero, no decimal point appears at all (but see "<tt>#</tt>" flag above).</td>
<td><tt>printf( "|%5.2f|", 3.147 );<br><br>
printf( "|%5.2G|", 3.147 );</tt></td><td><tt>|·3.15|<br><br>|··3.1|</tt></td></tr>
<tr><td>When used with integer conversion letters (d, i, o, u, x, and X) the precision specifies
the minimum number of digits to appear.&nbsp;
Leading zeros are added as needed.</td>
<td><tt>printf( "|%6.4i|", 17 );</tt></td><td><tt>|··0017|</tt></td></tr>
<tr><td>When used with string conversions (letter "s") the precision specifies the maximum
number of bytes written.&nbsp; (<a href="#" onclick="alert('The number of bytes doesn\'t '
+ 'always equal the width of the string; long strings (Unicode) uses one or two '
+ 'bytes per character.'); return false;">See note</a>.)&nbsp;
If the string is too long it will be truncated.</td>
<td><tt>printf( "|%-5.3s|", "ABCD" );</tt></td><td><tt>|ABC··|</tt></td></tr>

<tr valign="TOP"><th rowspan="9">
<a name="printfLen"></a>
length
</th><td colspan="3">
A <i>length modifier</i> is used to exactly specify the type of the matching argument.&nbsp;
Since most types are promoted to <tt>int</tt> or <tt>double</tt> a length modifier is
rarely used.&nbsp;
However it is used for <tt>long</tt> and other types that don't have an explicit conversion letter
of their own.&nbsp;
Note that specific length modifiers only make sense in combination with specific conversion letters.&nbsp;
Using undefined combinations causes unpredictable results.&nbsp;
The length modifiers and their meanings are:</td></tr>

<tr><td><table border="0"><tbody><tr valign="TOP"><td><tt>hh&nbsp;&nbsp;</tt></td><td>
Legal for integer conversions (d, i, o, u, x, or X conversion letters), specifies the matching
argument is a <tt>signed char</tt> for d and i, and <tt>unsigned char</tt> for o, u, x,
and X.&nbsp;
For an <tt>n</tt> conversion letter the matching argument is a pointer to a
<tt>signed char</tt>.&nbsp;
(New as of C99.)</td></tr></tbody></table>
</td>
<td><tt>printf( "%hhi", 300 );</tt> (<a href="#" onclick="alert('Since integer arguments to '
+ 'printf are always promoted to type int, the 300 here is not a problem even though the '
+ 'length says the argument is a char.  What really happens is that the int argument is '
+ 'demoted to char before the conversion to a string.  In this case an overflow results '
+ ' since 300 is larger than the max char value, causing unpredictable output.'); return false;">See note</a>)
</td><td><tt>44</tt></td></tr>

<tr><td><table border="0"><tbody><tr valign="TOP"><td><tt>h&nbsp;&nbsp;&nbsp;</tt></td><td>
The same as <tt>hh</tt>, except <tt>h</tt> specifies the argument
is a <tt>short</tt> or <tt>unsigned short</tt>.</td></tr></tbody></table>
</td>
<td><tt>printf( "%hi", 300 );</tt></td><td><tt>300</tt></td></tr>

<tr valign="TOP"><td><table border="0"><tbody><tr valign="TOP"><td><tt>l&nbsp;&nbsp;&nbsp;</tt></td><td>
(This is the letter <i>ell</i> and not the digit <i>one</i>.)&nbsp;
The same as <tt>hh</tt>, except <tt>l</tt> specifies the argument
is a <tt>long</tt> or <tt>unsigned long</tt>.<br><br>
For a <tt>c</tt> conversion the <tt>l</tt> length modifier specifies a matching
type of <tt>wint_t</tt>,
and for <tt>s</tt> the matching type is <tt>wchar_t</tt>.&nbsp;
(<a href="#" onclick="alert('This type and other Unicode '
+ '(also called wide char or multibyte char) related types, plus '
+ 'functions such as fwprintf, are declared in the header file wchar.h '
+ 'which is new with C99.'); return false;">See note</a>.)</td></tr></tbody></table>
</td>
<td><tt>long a = 300, b = (long) 1.0E+14;<br>printf( "%li\n%i", a, b );<br><br><br><br>
printf( "%lc:%ls", L'A', L"ABC" );</tt></td><td><tt><br>300<br>276447232<br><br><br>A:ABC</tt></td></tr>

<tr><td><table border="0"><tbody><tr valign="TOP"><td><tt>ll&nbsp;&nbsp;</tt></td><td>
(This is the letters <i>ell-ell</i> and not the digits <i>one-one</i>.)&nbsp;
The same as <tt>hh</tt>, except <tt>ll</tt> specifies the argument
is a <tt>long long</tt> or <tt>unsigned long long</tt>.&nbsp;
(New as of C99.)</td></tr></tbody></table>
</td>
<td><tt>printf( "%#llX", 300 );</tt></td><td><tt>0X12C</tt></td></tr>

<tr><td><table border="0"><tbody><tr valign="TOP"><td><tt>j&nbsp;&nbsp;&nbsp;</tt></td><td>
The same as <tt>hh</tt>, except <tt>j</tt> specifies the argument
is a <tt>intmax_t</tt> or <tt>uintmax_t</tt>.&nbsp;
(These types and length modifier are new as of C99.)</td></tr></tbody></table>
</td>
<td><tt>printf( "%ji", 17 );</tt></td><td><tt>17</tt></td></tr>

<tr><td><table border="0"><tbody><tr valign="TOP"><td><tt>z&nbsp;&nbsp;&nbsp;</tt></td><td>
The same as <tt>hh</tt>, except <tt>z</tt> specifies the argument
is a <tt>size_t</tt>.&nbsp;
(This length modifier is new as of C99.)</td></tr></tbody></table>
</td>
<td><tt>printf( "%zi", sizeof(int) );</tt></td><td><tt>4</tt></td></tr>

<tr><td><table border="0"><tbody><tr valign="TOP"><td><tt>t&nbsp;&nbsp;&nbsp;</tt></td><td>
The same as <tt>hh</tt>, except <tt>t</tt> specifies the argument
is a <tt>ptrdiff_t</tt>.&nbsp;
(This length modifier is new as of C99.)</td></tr></tbody></table>
</td>
<td><tt>char a[5] = "abcd";<br>
printf( "%ti", &amp;(a[3]) - &amp;(a[1]) );</tt></td><td><tt><br>2</tt></td></tr>

<tr><td><table border="0"><tbody><tr valign="TOP"><td><tt>L&nbsp;&nbsp;&nbsp;</tt></td><td>
Legal for floating point conversions (a, A, e, E, f, F, g, and G conversion letters),
specifies the matching argument is a <tt>long&nbsp;double</tt>.</td></tr></tbody></table>
</td>
<td><tt>printf( "%Lf", 3.14L );</tt></td><td><tt>3.140000</tt></td></tr>

</tbody></table>

<br><br>
<a name="scanf"></a>
<h2> scanf </h2>
<p>
A call to <tt>scanf</tt> looks like this:
</p><dir><tt>scanf( "<i>conversion-string</i>", &amp;<i>variable</i>, ... );</tt></dir>
<p>
Or, reading from a file using a <i>file handle</i> (<tt>stdin</tt> is a predefined
file handle but you can define your own via <tt>fopen</tt>) looks like this:
</p><dir><tt>fscanf( stdin, "<i>conversion-string</i>", &amp;<i>variable</i>, ... );</tt></dir>
The <i>conversion-string</i> can contain three types of <i>directives</i>:<p></p>
<table border="0" cellspacing="12">

<tbody><tr valign="TOP"><td> Regular characters </td><td>
This is text that must be matched character by character with the input.&nbsp;
Such entries are rarely used for interactive programs, but can be handy when working
with formatted input files.&nbsp;
(See <a href="#heightExample">below</a> for an example.)

</td></tr><tr valign="TOP"><td>white-space characters</td><td>
A blank, tab, or other white-space character will match any amount (including none)
of any white-space.&nbsp;
(So a single space will match any string of white-space, including newlines.)&nbsp;
Note that it is legal for this to match no input at all (if there isn't a blank or
tab, it is ok).

</td></tr><tr valign="TOP"><td>Conversion Specifiers</td><td>
Similar to <tt>printf</tt> conversion specifiers but just different enough to
cause many errors.&nbsp;
They all begin with a percent and end with a letter indicating the type of conversion.&nbsp;
In between can be some special conversion controls, including the <i>length</i>.&nbsp;
Unlike <tt>printf</tt>, failing to use the exact type and length for the conversion will
result in unpredictable errors.&nbsp;
Since few compilers will check the conversion-string for argument mis-matches, the result
is a runtime (logic) error that can be hard to find.&nbsp;
These conversion specifiers match a string of characters in the input, convert to the specified type (and
length), and store the result in the RAM address provided by the corresponding argument.&nbsp;
(The most common error with <tt>scanf</tt> is <b>not</b> using the <i>address-of</i>
operator in front of a variable name for the argument.)
</td></tr></tbody></table>

<a name="scanfRetCode"></a>
<h3> <tt>scanf</tt> Return Values </h3>
<p>
<tt>scanf</tt> returns a useful error code.&nbsp;
The return value is an <tt>int</tt> which indicates the number of conversions requested
that (1) matched some input, (2) were converted without error, and (3) were assigned without
any problems.&nbsp;
(Matching only, or matching and converting only, doesn't count in the return value.)&nbsp;
Depending on the error encountered the return value may be zero, <tt>EOF</tt> (a symbolic
constant usually defined to be <tt>-1</tt>), or some other integer
less than the number of requested conversions.&nbsp;
Because so many problems in programs are a result of bad user input, it is common practice
in production-quality code to <i>always</i> check the return value of <tt>scanf</tt>.
</p><p>
Here's an example use of <tt>scanf</tt> that attempts to read in two integers from an
<a href="#" onclick="alert('Working with files is another topic.  For now note '
+ 'predefined file handles such as stderr can be used, or you can create file '
+ 'handles yourself.  \'\'foo\'\' is such a file handle, say to a file '
+ '\'\'foo.dat\'\'.'); return false;">
input file</a> called <tt>foo</tt> that is formatted with lines like this:
</p><dir><tt>Height: 12, Width: 34</tt></dir>
<p><a name="heightExample"></a>
The C code fragment to read the numbers into variables <tt>height</tt> and <tt>width</tt>
should look something like this:
</p><dir><pre>int height, width;
if ( fscanf( foo, "Height: %i, Width: %i", &amp;height, &amp;width ) != 2 )
{  fprintf( stderr, "###Error with Scanf: bad input data.\a\n" );
   // Do error processing, maybe just "continue" or "break".
}
</pre></dir>
<p>
Here the <tt>fscanf</tt> is requesting two conversions, so if all goes well the return value
should be 2.&nbsp;
Note how the <tt>fscanf</tt> uses all three types of entires (regular text, white-space, and
conversion specifiers).&nbsp;
Although text such as "<tt>Height:</tt>" and "<tt>,</tt>" are matched, they don't count
toward the return value.
</p>
<a name="scanfMatch"></a>
<h3> Matching input </h3>
<p>
The system keeps track of which input has been seen so far.&nbsp;
Every call to <tt>scanf</tt> picks up from where the last one stopped matching
input.&nbsp;
This means that if an error occured with the previous <tt>scanf</tt>, the input it
failed to match is still left unread, as if the user typed ahead.&nbsp;
If care isn't taken to discard error input, and a loop is used to read the input,
your program can get caught in an infinite loop.&nbsp;
(See <a href="#ageExample">below</a> for an example and further discussion.)
</p><p>
For example, consider the program fragment above that reads in an age.&nbsp;
if the input is "<tt>help</tt>" instead of a number, this will cause the <tt>scanf</tt> to fail
when attempting to match an integer ("<tt>%i</tt>"), and the word <tt>help</tt>
is left unread.&nbsp;
So the next time through the loop, the <tt>scanf</tt> doesn't wait for fresh
user input, it tries to convert <tt>help</tt> again.
</p><p>
Similarly if the input were "<tt>17.5</tt>", the "<tt>%i</tt>" will match the
first two characters only (the <tt>17</tt>), leaving the <tt>.5</tt> as unread
input for the next call to <tt>scanf</tt>.
</p><p>
Even if the input is correct, as "<tt>29</tt>", the newline that ended the input
is still left unread.&nbsp;
Normally that isn't a problem since most conversions automatically skip leading
white-space such as the trailing newline from the previous line.&nbsp;
However some conversions ("<tt>%c</tt>" and "<tt>%[</tt>") don't skip any
leading white-space so you have to do it manually.
</p><p>
Note that all input functions that read from <tt>stdin</tt> share the same
<a href="#" onclick="alert('The operating system doesn\'t send data from a file or '
+ 'from the keyboard immediately to your program.  (This gives users typing at the '
+ 'keyboard a chance to use backspace.)  Likewise output doesn\'t go directly to '
+ 'a file or the screen.  The operating system holds data in \'\'buffers\'\' and '
+ 'generally only sends the data when the buffers get full.  This usually improves '
+ 'I/O speed.'); return false;">input buffer</a>,
so if a call to <tt>scanf("%i",&nbsp;&amp;anInt);</tt> is followed by
a call to <tt>getchar()</tt>, the newline left unread by scanf is read in now.&nbsp;
This is not usually what is wanted.
</p><p>
A final warning: Some older compilers will <b>not</b> match any regular text after
the last conversion specifier in the conversion-string.&nbsp;
This bug would prevent the example for "<tt>%%</tt>" below from working correctly.
</p>
<a name="scanfConv"></a>
<center><table border="1" cellpadding="6">
<caption align="TOP"><big><tt>scanf</tt> Conversion Letters and Matching Types</big></caption>
<tbody><tr><th>Letter</th><th>Type of Matching Argument</th><th>Auto-skip<br>Leading<br>White-Space</th>
<th>Example</th><th>Sample Matching Input</th></tr>

<tr valign="TOP"><th><tt>%</tt></th><td><tt>%</tt> (a literal, matched but not converted or assigned)</td>
<th>no</th><td><tt>int anInt;<br>scanf("%i%%", &amp;anInt);</tt></td>
<td><tt>23%</tt></td></tr>

<tr valign="TOP"><th><tt>d</tt></th><td><tt>int</tt> (<a href="#" onclick="alert('Converts '
+ 'strings of decimal digits to integers, but not octal or hex strings.  The numbers may '
+ 'be either positive or negative.  The type of the argument is determined by a length '
+ 'modifier (See the table below).'); return false;">See note</a>)</td>
<th>yes</th><td><tt>int anInt; long l;<br>scanf("%d %ld", &amp;anInt, &amp;l);</tt></td>
<td><tt>-23 200</tt></td></tr>

<tr valign="TOP"><th><tt>i</tt></th><td><tt>int</tt> (<a href="#" onclick="alert('Converts '
+ 'strings of decimal, octal, or hex digits to integers.  This is usually a more flexible '
+ 'choice than using %d, %o, %u, or %x.'); return false;">See note</a>)</td>
<th>yes</th><td><tt>int anInt;<br>scanf("%i", &amp;anInt);</tt></td><td><tt>0x23</tt></td></tr>

<tr valign="TOP"><th><tt>o</tt></th><td><tt>unsigned int</tt> (<a href="#" onclick="alert('Converts '
+ 'strings of octal digits (begins with leading zero) to integers.'); return false;">See note</a>)</td>
<th>yes</th><td><tt>unsigned int aUInt;<br>scanf("%o", &amp;aUInt);</tt></td><td><tt>023</tt></td></tr>

<tr valign="TOP"><th><tt>u</tt></th><td><tt>unsigned int</tt> (<a href="#" onclick="alert('Converts '
+ 'strings of decimal digits to integers, but not octal or hex strings.'); return false;">See note</a>)</td>
<th>yes</th><td><tt>unsigned int aUInt;<br>scanf("%u", &amp;aUInt);</tt></td><td><tt>23</tt></td></tr>

<tr valign="TOP"><th><tt>x</tt></th><td><tt>unsigned int</tt> (<a href="#" onclick="alert('Converts '
+ 'strings of hexdecimal digits to integers.'); return false;">See note</a>)</td>
<th>yes</th><td><tt>unsigned int aUInt;<br>scanf("%d", &amp;aUInt);</tt></td><td><tt>1A</tt></td></tr>

<tr valign="TOP"><th><tt>a, e, f, g</tt></th><td><tt>float</tt> or <tt>double</tt>
(<a href="#" onclick="alert('Converts floating point strings such as 10 or 3.2 or 2.2E+03.  '
+ 'All these letters have the same effect, as do the upper-case letters.  The type of the variable '
+ 'is determined by a length modifier (see the table below).'); return false;">See note</a>)</td>
<th>yes</th><td><tt>float f; double d;<br>scanf("%f %lf", &amp;f, &amp;d);</tt></td>
<td><tt>1.2 3.4</tt></td></tr>

<tr valign="TOP"><th><tt>c</tt></th><td><tt>char</tt> (<a href="#" onclick="alert('Converts '
+ 'a character, or multibyte (Unicode) character if a length modifier is used, '
+ 'or a string of characters if a field width modifier is used.  When using any modifier '
+ 'the argument should be an array of char, which is *not* null-terminated.  (Note the explicit '
+ 'skip of leading white-space in the example.)'); return false;">See note</a>)</td>
<th>no</th><td><tt>char ch;<br>scanf(" %c", &amp;ch);</tt></td><td><tt>Q</tt></td></tr>

<tr valign="TOP"><th><tt>s</tt></th><td><tt>array of char</tt> (<a href="#" onclick="alert('Converts '
+ 'strings of characters, but only up to the first white-space character.  This essentially reads '
+ 'input a word at a time.  The resulting string is null-terminated.  NOTE:  You should '
+ '*always* use a field width with %s, to avoid a buffer over-run error!  (Also note no \'&amp;\' is '
+ 'needed when the argument is an array.)'); return false;">See note</a>)</td>
<th>yes</th><td><tt>char s[30];<br>scanf("%29s", s);</tt></td><td><tt>hello</tt></td></tr>

<tr valign="TOP"><th><tt>p</tt></th><td><tt>void</tt> (<a href="#" onclick="alert('Converts '
+ 'string that represents a pointer (as saved by the printf \'%p\' convertsion).  The exact '
+ 'value of a pointer string is implementation defined.'); return false;">See note</a>)</td>
<th>yes</th><td><tt>int* pi; void* ptr;<br>scanf("%p", &amp;ptr);<br>pi = (int*) ptr;</tt></td>
<td><tt>0064FE00</tt></td></tr>

<tr valign="TOP"><th><tt>n</tt></th><td><tt>int</tt> (<a href="#" onclick="alert('Stores in '
+ 'the int pointed to, the number of characters read from the input so far by this scanf call.  '
+ 'No input is consumed, and the return value is not incremented.'); return false;">See note</a>)</td>
<th>no</th><td><tt>int x, cnt;<br>scanf("X: %d%n", &amp;x, &amp;cnt);</tt></td>
<td><tt>X: 123</tt> &nbsp;(<i>cnt==6</i>)</td></tr>

<tr valign="TOP"><th><tt>[</tt></th><td><tt>array of char</tt> (<a href="#" onclick="alert('Converts the '
+ 'longest string consisting of only the characters after the \'[\' up to the first matching \']\'.  '
+ 'If the first character after the \'[\' is \'^\', then the matching string is all characters up to the '
+ 'first of the listed characters.  (A \']\' character can be included in the list if it is '
+ ' first \'\'%[]ABC]\'\' or \'\'%[^[ABC]\'\'.  A hyphen must be first or last to be included (\'\'%[ABC-]\'\').  '
+ 'A hyphen in the middle indicates a range (\'\'%[A-Za-z0-9]\'\'), although this is implementation defined.  This '
+ 'conversion is often used to read a line up to a newline, or fields from (tab) delimited data files as '
+ 'in the example.  The resulting string is null-terminated.'); return false;">See note</a>)</td>
<th>no</th><td><tt>char s1[64], s2[64];<br>scanf(" %[^\n]", s1);<br>scanf("%[^\t] %[^\t]", s1, s2);</tt></td>
<td><br><tt>Hello World<br>field1  &nbsp; field2</tt></td></tr>

</tbody></table></center><br><br><br>

<a name="scanfFormat"></a>
<h2> <tt>scanf</tt> Format Specification Syntax </h2>
<p>
The control of input conversion is much simpler than for output conversions.&nbsp;
Any, all, or none of the following format <i>modifiers</i> may be used between the %
and the final letter of the conversion specification.&nbsp;
Note these must appear (if at all) in the sequence shown here.&nbsp;
A <tt>·</tt> is used to indicate a space in the example output where spacing is not obvious.
</p><dir><nobr><tt>% &nbsp; * &nbsp; <i>maximum-field-width &nbsp; length</i> &nbsp; Letter</tt></nobr>
</dir>
<br><br>
<a name="scanfAssign"></a>
<table border="1" cellpadding="6">
<tbody><tr><th>Conversion<br>Modifier</th><th>Description</th><th>Example</th><th>Matching<br>Input</th>
<th>Results</th></tr>

<tr valign="TOP"><th><tt>*</tt></th>
<td>Assignment Supression.&nbsp; This modifier causes the corresponding
input to be matched and converted, but not assigned (no matching argument is needed).</td>
<td><tt>int&nbsp;anInt;<br>scanf("%*s&nbsp;%i",&nbsp;&amp;anInt);</tt></td>
<td><br><tt>Age:·29</tt></td>
<td><tt>anInt==29,<br>return value==1</tt></td></tr>

<tr valign="TOP"><th><a name="scanfWidth"><tt>maximum<br>field-width</tt></a></th>
<td>This is the maximum number of character to read from the input.&nbsp;
Any remaining input is left unread.&nbsp;
(<strong>Always</strong> use this with "<tt>%s</tt>" and "<tt>%[...]</tt>" in
<strong>all</strong> production quality code!&nbsp;
(No exceptions!)&nbsp;
You should use one less than the size of the array used to hold the result.)</td>
<td><tt>int&nbsp;anInt;&nbsp;char s[10];<br>scanf("%2i",&nbsp;&amp;anInt);<br><br>
scanf("%9s",&nbsp;s);</tt></td>
<td><br><tt>2345<br><br>VeryLongString</tt></td>
<td><tt>anInt==23,<br>return&nbsp;value==1<br><br>s=="VeryLongS"
<br>return&nbsp;value==1</tt></td></tr>

<tr valign="TOP"><th rowspan="2"><a name="scanfLen"><tt>length<br>modifier</tt></a></th>
<td colspan="4">This specifies the exact type of the matching arugment.&nbsp;
These length codes are the same as the <a href="#printfLen">printf length modifiers</a>,
except as noted below:</td></tr>

<tr><td><table border="0"><tbody><tr valign="TOP"><td><tt>l&nbsp;&nbsp;</tt></td><td>
The same for integer conversions (d, i, o, u, x, or X conversion letters), specifies the matching
argument is a <tt>long int</tt>.&nbsp; For floating point (a, A, e, E, f, F, g, or G conversion letters)
an "l" has no effect in a <tt>printf</tt>, <b>but with <tt>scanf</tt>, an ell specifies a
<tt>double</tt></b>.&nbsp;
</td></tr></tbody></table>
</td>
<td><tt>double&nbsp;d;<br>scanf("%lf",&nbsp;&amp;d);</tt>
</td><td><tt>3.14</tt></td><td><tt>d==3.14<br>return&nbsp;value==1</tt></td></tr>

</tbody></table>
<br><br>
<a name="scanfExamples"></a>
<h2> Examples Using <tt>scanf</tt> and Other Input Techniques </h2>
<ol>
<br><li>
<h3>Example:&nbsp; Matching</h3>
<p>
The <tt>scanf</tt> call:</p>
<dir><pre>int i;  float x;  char name[50];
scanf( "%2d%f%*d %[0123456789]", &amp;i, &amp;x, name );
</pre></dir><p>
With this input:</p>
<dir><pre>56789 0123 56a72
</pre></dir><p>
will assign to <tt>i</tt> the value <tt>56</tt> and to <tt>x</tt> the value <tt>789.0</tt>,
will skip <tt>0123</tt>, and assign to <tt>name</tt> the sequence <tt>56\0</tt>
(the string "<tt>56</tt>").&nbsp;
The next character to be read from the input will be <tt>a</tt>.
</p></li>
<br><br><li>
<a name="ageExample"></a>
<h3>Example:&nbsp; non-GUI Interractive Input</h3>
<p>
A simple (and common) example reads an <tt>int</tt> from a user this way:</p>
<dir><pre>int age;
for ( ;; )
{  fprintf( stderr, "Please enter your age: " );
   if ( scanf( "%i", &amp;age ) = 1 )
      break;
   // Do some sort of error processing:
   fprintf( stderr, "\nError reading in the age, please try again.\n" );
}
printf( "You are %i years old.\n", age );
</pre></dir>
<p>
Note the use of <tt>fprintf</tt> to send the output to the screen even if output was
redirected.&nbsp;
Some common error processing is to reset the variables and try again, using a loop
as shown here.&nbsp;
Sometimes a count of attempts is kept and the user is only given a certain number of
attempts before the program gives up.
</p>
</li>
<br><br><li>
<a name="fgetsExample"></a>
<h3>Example: Line (record) at a time input</h3>
<p>
A problem with <tt>scanf</tt> is that it leaves any unmatched input unread.&nbsp;
This may be a problem for applications that expect <em>line oriented</em> input.&nbsp;
When each line (or <em>record</em>) of input is to be processed independently, an
error such as bad data on one line can cause errors when attempting to read the
following line.
</p><p>
Consider the code <a href="#ageExample">above</a> to read in an age.&nbsp;
If the input entered by the user was non-numeric such as the word "<tt>help</tt>",
the "<tt>h</tt>" would not match the "<tt>%i</tt>" and would be left unread.&nbsp;
When the <tt>for</tt> loop repeated, the <tt>scanf</tt> would encounter the "<tt>h</tt>"
again and immediately fail.&nbsp;
This would cause an infinite loop!
</p><p>
A similar problem would exist if the user entered "<tt>29.5</tt>" for their age.&nbsp;
The first time through the loop the <tt>scanf</tt> would read the <tt>29</tt>.&nbsp;
If the next input expected was a person's name or ID or whatever, the "<tt>.5</tt>"
will be read next.
</p><p>
Another common problem with this approach is mixing <tt>scanf</tt> with <tt>getchar</tt>
or <tt>getc</tt>.&nbsp;
The <tt>scanf</tt> typically leaves the <em>newline</em> unread, so a call to read the
next character retrieves that instead of the character the programmer expected to get.&nbsp;
(This problem may be worse on DOS based systems, which have two characters to mark
the end of lines.)
</p><p>
The solution is to use <tt>fgets</tt> (see&nbsp;<a href="#" onclick="alert('Never use '
+ 'the \'\'gets\'\' function instead of \'\'fgets\'\'.  \'\'gets\'\' has no maximum '
+ 'length argument the way \'\'fgets\'\' does.  This causes a potentially very dangerous '
+ '\'\'buffer overrun\'\' condition.  (\'\'scanf\'\' with \'\'%s\'\' or \'\'%[\'\' has '
+ 'the same problem, so always use a field-width in those cases.)'); return false;">note</a>)
to read input a line at a time into a buffer,
then use the <tt>sscanf</tt> function to parse the contents of the buffer.&nbsp;
With this approach each input operation consumes (reads) an entire line of input,
even if it had errors.&nbsp;
The next input operation starts fresh with the next line of input.
</p><p>
Here's an example to illustrate the technique:
</p>
<dir><pre>char buf[BUFSIZ];     /* Buffer for a line of input. */
int age;

fprintf( stderr, "Please enter your age: " );
while ( fgets( buf, sizeof(buf), stdin ) != NULL )
{
   if ( sscanf( buf, "%i", &amp;age ) != 1 )
      break;
   // Do some sort of error processing:
   fprintf( stderr, "\nError reading in the age, please try again.\n" );
}
</pre></dir>
<p>
The call to <tt>fgets</tt> reads all input up to and including a newline.&nbsp;
It then copies that line of input into <tt>buf</tt>, adding a <tt>'\0'</tt> at the
end to form a valid <em>C&nbsp;string</em>.&nbsp;
The terminating newline is also copied into <tt>buf</tt>.&nbsp;
On <tt>EOF</tt>, <tt>fgets</tt> returns <tt>NULL</tt>.&nbsp;
(<tt>EOF</tt> and <tt>NULL</tt> are defined in <tt>&lt;stdio.h&gt;</tt>.)&nbsp;
If the input is larger than the size of the buffer, than only the input that will
fit is consumed (read).&nbsp;
Note <tt>fgets</tt> is smart enough to reserve space for the <tt>'\0'</tt> from
the size given.&nbsp;
In this case the maximum input read would be <tt>BUFSIZ-1</tt>.
</p><p>
The <tt>sscanf</tt> works just like <tt>scanf</tt> or <tt>fscanf</tt>.&nbsp;
The first argument to <tt>sscanf</tt> is the <em>string</em> to read from
(instead of <tt>stdin</tt> as for <tt>scanf</tt>).&nbsp;
If the <tt>fgets</tt> doesn't detect <tt>EOF</tt> but the <tt>sscanf</tt>
fails to match any input using <tt>"%s"</tt>, the input must have been a blank
line.&nbsp;
When using <tt>"%i"</tt> and not a <tt>"%s"</tt>,
the return value doesn't tell if the input was a blank line or some other error.
</p></li>
<br><br><li>
<a name="extraInputExample"></a>
<h3>Example: Detecting extraneous input</h3>
<p>
The line at a time example <a href="#fgetsExample">above</a> works well
but doesn't detect all errors.&nbsp;
Consider what would happen if the user entered <tt>29.5</tt> for an age, or
<tt>32,500</tt> for some numeric value (such as a person's income in dollars).&nbsp;
While the <tt>fgets</tt> will read the whole line, the <tt>sscanf</tt> will
only read <tt>29</tt> in the first case and <tt>32</tt> in the second.&nbsp;
In both cases <tt>sscanf</tt> will return <tt>1</tt> and the errors would
go undetected.
</p><p>
In order to detect such extra input on the line <tt>scanf</tt> must
attempt to match it, convert it, and assign it to a variable.&nbsp;
Then the return value will be <tt>2</tt> if extra input was present.&nbsp;
There are two ways to do this.&nbsp;
If extra white space is not considered an error you can use "<tt>%s</tt>"
instead of the "<tt>%[</tt>" used below:
</p>
<dir><pre>char buf[BUFSIZ], junk[BUFSIZ];
int income;

fprintf( stderr, "Please enter your income: " );
while ( fgets( buf, sizeof(buf), stdin ) != NULL )
{
   if ( sscanf( buf, "%i%[^\n]", &amp;income, junk ) != 1 )
      break;
   // Do some sort of error processing:
   fprintf( stderr, "\nError reading your income, please try again.\n" );
}
</pre></dir>
<p>
Here the <tt>sscanf</tt> will skip leading white space (<tt>%i</tt> does
this automatically), match digits until the first non-digit, convert the
matched string to
an <tt>int</tt> and assign the result to <tt>income</tt>.&nbsp;
<tt>sscanf</tt> then matches any remaining
characters (up to but not including a newline) and stores the string
in <tt>junk</tt>.&nbsp;
If there were no input errors, the <tt>%i</tt> would succeed but the
<tt>%[^\n]</tt> will fail to match any input.&nbsp;
The return value would therefore be <tt>1</tt>.&nbsp;
However if any extra input was encountered the <tt>%[^\n]</tt> will match it
and assign the string to <tt>junk</tt>.&nbsp;
This would cause <tt>sscanf</tt> to return <tt>2</tt>.&nbsp;
If the user input was "<tt>$32500</tt>, the <tt>%i</tt> would fail to
match anything and the return value would be <tt>0</tt>.&nbsp;
This technique will therefore catch any input errors and
consume the entire line (record) whether or not errors were present.
</p></li>
</ol>

<br><br> <hr width="65%"><br>
<a name="CharConstants"></a>
<h2> Character Constants </h2>
<p>Below is a table of character constants.&nbsp;
These can be used individually (as a <tt>char</tt> literal by surrounding
the constant with single quotes) or as part of a double-quoted string literal.
</p>
<center>
<table border="1" cellpadding="6">
<tbody><tr><th><i>Constant</i></th><th><i>Meaning</i></th></tr>
<tr><th><tt>\'</tt></th><td>A single quote</td></tr>
<tr><th><tt>\"</tt></th><td>A double quote</td></tr>
<tr><th><tt>\?</tt></th><td>A question mark</td></tr>
<tr><th><tt>\\</tt></th><td>A backslash</td></tr>
<tr><th><tt>\a</tt></th><td>Alert sound</td></tr>
<tr><th><tt>\b</tt></th><td>A backspace</td></tr>
<tr><th><tt>\f</tt></th><td>A form-feed</td></tr>
<tr><th><tt>\n</tt></th><td>A newline</td></tr>
<tr><th><tt>\r</tt></th><td>A carrage-return</td></tr>
<tr><th><tt>\t</tt></th><td>A tab</td></tr>
<tr><th><tt>\v</tt></th><td>A vertical tab</td></tr>
<tr><th><tt>\<i>ooo</i></tt></th><td>Octal constant (up to three octal digits)</td></tr>
<tr><th><tt>\x<i>HH</i></tt></th><td>Hexadecimal constant (one or two hex digits)</td></tr>
<tr><th><tt>\u<i>HHHH</i></tt></th><td>Unicode constant (four hex digits)</td></tr>
<tr><th><tt>\U<i>HHHHHHHH</i></tt></th><td>Long Unicode constant (eight hex digits)</td></tr>
</tbody></table>
</center>
<p></p><h3>Notes:</h3><p></p>
<p>
The C standard doesn't use the term <em>Unicode character</em> much, the authors prefer
the term <em>Universal character</em>.&nbsp;
It's pretty clear that they mean Unicode though, since it is refered to by it's
official name of "ISO/IEC 10646" in several places.&nbsp;
Unicode is actually a 4 byte per character encoding, however most non-asian characters
are found in the lower half of the character set, so the 2 byte form is common.&nbsp;
(Actually Unicode is often stored in files in a form called <tt>UTF-8</tt>.)
</p><p>
Such <em>multibyte characters</em> are called <tt>wchar_t</tt> constants.&nbsp;
You can make a literal for one as follows:&nbsp; <tt>L'\u00A9'</tt> (which is the
same character as <tt>'\xA9'</tt>, namely the "<tt>©</tt>" symbol).&nbsp;
You can also form <em>wide strings</em> such as:&nbsp; <tt>L"\u00A92001"</tt>,
which translates to the string "<tt>©2001</tt>".
</p>
<br><br>
<hr width="65%">
<p>
<a name="About"></a>
This information was extracted from ISO/IEC 9899, second edition (the C99 Standard),
mostly from sections 7.19.6.1 and 7.19.6.2.&nbsp;
</p>

<br><br>
<hr size="2">
<table border="0" width="100%">
<tbody><tr valign="TOP"><td>
Send comments and mail to the
<a href="mailto:pollock@acm.org?subject=C%20Question:%20Printf-Scanf">
WebMaster</a>.
</td><td align="RIGHT">
<script language="JavaScript">
<!--
    var LastModDate = document.lastModified;
    var msg = "<I> Last updated by Wayne Pollock on " +
              LastModDate + ". </I>";
    document.writeln( msg );
//  -->
</script><i> Last updated by Wayne Pollock on 08/20/2009 11:07:41. </i>

</td></tr></tbody></table>

</body></html>